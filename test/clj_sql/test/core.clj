(ns clj-sql.test.core
  "Tests for clj-sql as a whole"
  (:use clojure.test)
  (:use clojure.contrib.strint)
  (:use clj-sql.test.select)
  (:import [org.h2.jdbcx JdbcConnectionPool])
  (:require [clj-sql.core :as sql]))

;;======== In memory H2 database ===============================================
(def h2-db
     {:datasource (JdbcConnectionPool/create 
                   "jdbc:h2:mem:test",
                   "sa","")
      :auto-increment "generated by default as identity"})

;;======== In memory Derby database ============================================
(def derby-db
     {:classname "org.apache.derby.jdbc.EmbeddedDriver"
      :subprotocol "derby"
      :subname "memory:test"
      :create true
      :auto-increment "generated by default as identity"})

;;======== Optional external Mysql database ====================================

(def mysql-db
     {:classname "com.mysql.jdbc.Driver"
      :subprotocol "mysql"
      :subname "///clj_sql_unittest"
      :user "unittest"
      :password "password"
      :auto-increment "not null AUTO_INCREMENT"})

;;======== Global defs =========================================================

;; The dbs being tested
(def dbs* [h2-db derby-db mysql-db])


;; The current db under test
(def *current-db* nil)

;;======== Helper functions that can be run from the repl ======================
      

(defn create-tables [db-spec]
  (sql/create-table
   :test-one
   [:id :int (db-spec :auto-increment)]
   [:my-txt "varchar(20)"]
   ["primary key" [:id]])
  (sql/create-table
   :test-two
   [:id :int (db-spec :auto-increment)]
   [:num-field :int]
   [:my-txt "varchar(20)"]
   ["primary key" [:id]]
   ["foreign key" [:num-field] "references" :test-one [:id]]))

(defn reset
  "Drops the test tables without error"
  []
  (try
    (sql/drop-table :test-two)
    (catch Exception _))
  (try
    (sql/drop-table :test-one)
    (catch Exception _)))

;;======== Unittests ===========================================================

(defn run-test
  "Runs a unittest function f"
  [f]
  (doseq [db dbs*]
    (binding [*current-db* db]
      (sql/with-connection db
        (reset)
        (create-tables db)
        (f)))))

(use-fixtures :each run-test)

(deftest create
  ;; An exception will be thrown if no table exists
  (is (nil? (select [:*] [:test-one]))))

(deftest insert
  (sql/insert-values :test-one [:my-txt] ["xxx"])
  (is (= (select [:id :my-txt] [:test-one])
         [{:id 1 :my-txt "xxx"}])))

(deftest insert-record
  (is (= 1
         (sql/insert-record :test-one {:my-txt "xxx"})))
  (is (= 2
         (sql/insert-record :test-one {:my-txt "yyy"}))))

(deftest insert-with-id
  (sql/insert-with-id
    :test-one {:my-txt "xxx"}
    :test-two {:num-field (id :test-one)
               :my-txt "yyy"})
  (is (=
       (select {:test-one.id "one"
                :test-two.id "two"
                :test-two.num-field "num-field-two"
                :test-one.my-txt "txt-field-one"
                :test-two.my-txt "txt-field-two"}
               [:test-one :test-two]
               {:test-one.id :test-two.num-field})
       [{:one 1               :two 1
                              :num-field-two 1
         :txt-field-one "xxx" :txt-field-two "yyy"}]
       )))

(deftest do-insert
  (let [table (sql/quote-name :test-one)
        field (sql/quote-name :my-txt)]
    (is (= 1
           (sql/do-insert
            (<< "insert into ~{table} (~{field}) values (?)")
            ["xxx"])))
    (is (= 2
           (sql/do-insert
            (<< "insert into ~{table} (~{field}) values (?)")
            ["yyy"])))
    ;; Derby database doesn't support the SQL below and the Derby driver
    ;; has an NPE when using an alternative SQL syntax
    ;; Mysql doesn't support SQL below
    (if-not (#{derby-db mysql-db} *current-db*) 
      (do
        (is (= 3
               (sql/do-insert
                (<<
                 "insert into ~{table} (~{field})
                  select ? where not exists
                  (select id from ~{table} where ~{field} = ?)")
                ["zzz" "zzz"])))
        (is (nil?
             (sql/do-insert
              (<<
               "insert into ~{table} (~{field})
                select ? where not exists
                (select id from ~{table} where ~{field} = ?)")
              ["zzz" "zzz"])))))))
  
